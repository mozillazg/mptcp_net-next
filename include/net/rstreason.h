/* SPDX-License-Identifier: GPL-2.0-or-later */

#ifndef _LINUX_RSTREASON_H
#define _LINUX_RSTREASON_H
#include <net/dropreason-core.h>

#define DEFINE_RST_REASON(FN, FNe)	\
	FN(MPTCP_RST_EUNSPEC)		\
	FN(MPTCP_RST_EMPTCP)		\
	FN(MPTCP_RST_ERESOURCE)		\
	FN(MPTCP_RST_EPROHIBIT)		\
	FN(MPTCP_RST_EWQ2BIG)		\
	FN(MPTCP_RST_EBADPERF)		\
	FN(MPTCP_RST_EMIDDLEBOX)	\
	FN(NOT_SPECIFIED)		\
	FNe(MAX)

#define RST_REASON_START (SKB_DROP_REASON_MAX + 1)

/* There are three parts in order:
 * 1) 0 - SKB_DROP_REASON_MAX: rely on drop reasons for passive reset in TCP
 * 2) SKB_DROP_REASON_MAX + 1 - MPTCP_RST_EMIDDLEBOX: for MPTCP use
 * 3) MPTCP_RST_EMIDDLEBOX - SK_RST_REASON_MAX: independent reset reason
 */
enum sk_rst_reason {
	/* Leave this 'blank' part (0-SKB_DROP_REASON_MAX) for the reuse
	 * of skb drop reason because rst reason relies on what drop reason
	 * indicates exactly why it could happen.
	 */

	/* Copy from include/uapi/linux/mptcp.h.
	 * These reset fields will not be changed since they adhere to
	 * RFC 8684. So do not touch them. I'm going to list each definition
	 * of them respectively.
	 */
	/* Unspecified error.
	 * This is the default error; it implies that the subflow is no
	 * longer available. The presence of this option shows that the
	 * RST was generated by an MPTCP-aware device.
	 */
	SK_RST_REASON_MPTCP_RST_EUNSPEC = RST_REASON_START,
	/* MPTCP-specific error.
	 * An error has been detected in the processing of MPTCP options.
	 * This is the usual reason code to return in the cases where a RST
	 * is being sent to close a subflow because of an invalid response.
	 */
	SK_RST_REASON_MPTCP_RST_EMPTCP,
	/* Lack of resources.
	 * This code indicates that the sending host does not have enough
	 * resources to support the terminated subflow.
	 */
	SK_RST_REASON_MPTCP_RST_ERESOURCE,
	/* Administratively prohibited.
	 * This code indicates that the requested subflow is prohibited by
	 * the policies of the sending host.
	 */
	SK_RST_REASON_MPTCP_RST_EPROHIBIT,
	/* Too much outstanding data.
	 * This code indicates that there is an excessive amount of data
	 * that needs to be transmitted over the terminated subflow while
	 * having already been acknowledged over one or more other subflows.
	 * This may occur if a path has been unavailable for a short period
	 * and it is more efficient to reset and start again than it is to
	 * retransmit the queued data.
	 */
	SK_RST_REASON_MPTCP_RST_EWQ2BIG,
	/* Unacceptable performance.
	 * This code indicates that the performance of this subflow was
	 * too low compared to the other subflows of this Multipath TCP
	 * connection.
	 */
	SK_RST_REASON_MPTCP_RST_EBADPERF,
	/* Middlebox interference.
	 * Middlebox interference has been detected over this subflow,
	 * making MPTCP signaling invalid. For example, this may be sent
	 * if the checksum does not validate.
	 */
	SK_RST_REASON_MPTCP_RST_EMIDDLEBOX,

	/* For the real standalone socket reset reason, we start from here */
	SK_RST_REASON_NOT_SPECIFIED,

	/* Maximum of socket reset reasons.
	 * It shouldn't be used as a real 'reason'.
	 */
	SK_RST_REASON_MAX,
};

static inline enum sk_rst_reason convert_mptcp_reason(int reason)
{
	return reason += RST_REASON_START;
}
#endif
