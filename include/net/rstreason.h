/* SPDX-License-Identifier: GPL-2.0-or-later */

#ifndef _LINUX_RSTREASON_H
#define _LINUX_RSTREASON_H
#include <net/dropreason-core.h>
#include <uapi/linux/mptcp.h>

#define DEFINE_RST_REASON(FN, FNe)	\
	FN(MPTCP_RST_EUNSPEC)		\
	FN(MPTCP_RST_EMPTCP)		\
	FN(MPTCP_RST_ERESOURCE)		\
	FN(MPTCP_RST_EPROHIBIT)		\
	FN(MPTCP_RST_EWQ2BIG)		\
	FN(MPTCP_RST_EBADPERF)		\
	FN(MPTCP_RST_EMIDDLEBOX)	\
	FN(NOT_SPECIFIED)		\
	FN(NO_SOCKET)			\
	FNe(MAX)

/**
 * There are three parts in order:
 * 1) reset reason in MPTCP: only for MPTCP use
 * 2) skb drop reason: relying on drop reasons for such as passive reset
 * 3) independent reset reason: such as active reset reasons
 */
enum sk_rst_reason {
	/**
	 * Copy from include/uapi/linux/mptcp.h.
	 * These reset fields will not be changed since they adhere to
	 * RFC 8684. So do not touch them. I'm going to list each definition
	 * of them respectively.
	 */
	/**
	 * @SK_RST_REASON_MPTCP_RST_EUNSPEC: Unspecified error.
	 * This is the default error; it implies that the subflow is no
	 * longer available. The presence of this option shows that the
	 * RST was generated by an MPTCP-aware device.
	 */
	SK_RST_REASON_MPTCP_RST_EUNSPEC,
	/**
	 * @SK_RST_REASON_MPTCP_RST_EMPTCP: MPTCP-specific error.
	 * An error has been detected in the processing of MPTCP options.
	 * This is the usual reason code to return in the cases where a RST
	 * is being sent to close a subflow because of an invalid response.
	 */
	SK_RST_REASON_MPTCP_RST_EMPTCP,
	/**
	 * @SK_RST_REASON_MPTCP_RST_ERESOURCE: Lack of resources.
	 * This code indicates that the sending host does not have enough
	 * resources to support the terminated subflow.
	 */
	SK_RST_REASON_MPTCP_RST_ERESOURCE,
	/**
	 * @SK_RST_REASON_MPTCP_RST_EPROHIBIT: Administratively prohibited.
	 * This code indicates that the requested subflow is prohibited by
	 * the policies of the sending host.
	 */
	SK_RST_REASON_MPTCP_RST_EPROHIBIT,
	/**
	 * @SK_RST_REASON_MPTCP_RST_EWQ2BIG: Too much outstanding data.
	 * This code indicates that there is an excessive amount of data
	 * that needs to be transmitted over the terminated subflow while
	 * having already been acknowledged over one or more other subflows.
	 * This may occur if a path has been unavailable for a short period
	 * and it is more efficient to reset and start again than it is to
	 * retransmit the queued data.
	 */
	SK_RST_REASON_MPTCP_RST_EWQ2BIG,
	/**
	 * @SK_RST_REASON_MPTCP_RST_EBADPERF: Unacceptable performance.
	 * This code indicates that the performance of this subflow was
	 * too low compared to the other subflows of this Multipath TCP
	 * connection.
	 */
	SK_RST_REASON_MPTCP_RST_EBADPERF,
	/**
	 * @SK_RST_REASON_MPTCP_RST_EMIDDLEBOX: Middlebox interference.
	 * Middlebox interference has been detected over this subflow,
	 * making MPTCP signaling invalid. For example, this may be sent
	 * if the checksum does not validate.
	 */
	SK_RST_REASON_MPTCP_RST_EMIDDLEBOX,

	/**
	 * Refer to include/net/dropreason-core.h
	 * Rely on skb drop reason because it indicates exactly why RST
	 * could happen.
	 */
	/** @SK_RST_REASON_NOT_SPECIFIED: reset reason is not specified */
	SK_RST_REASON_NOT_SPECIFIED,
	/** @SK_RST_REASON_NO_SOCKET: no valid socket that can be used */
	SK_RST_REASON_NO_SOCKET,

	/** @SK_RST_REASON_ERROR: unexpected error happens */
	SK_RST_REASON_ERROR,

	/**
	 * @SK_RST_REASON_MAX: Maximum of socket reset reasons.
	 * It shouldn't be used as a real 'reason'.
	 */
	SK_RST_REASON_MAX,
};

/* Convert reset reasons in MPTCP to our own enum type */
static inline enum sk_rst_reason convert_mptcpreason(u32 reason)
{
	switch (reason) {
	case MPTCP_RST_EUNSPEC:
		return SK_RST_REASON_MPTCP_RST_EUNSPEC;
	case MPTCP_RST_EMPTCP:
		return SK_RST_REASON_MPTCP_RST_EMPTCP;
	case MPTCP_RST_ERESOURCE:
		return SK_RST_REASON_MPTCP_RST_ERESOURCE;
	case MPTCP_RST_EPROHIBIT:
		return SK_RST_REASON_MPTCP_RST_EPROHIBIT;
	case MPTCP_RST_EWQ2BIG:
		return SK_RST_REASON_MPTCP_RST_EWQ2BIG;
	case MPTCP_RST_EBADPERF:
		return SK_RST_REASON_MPTCP_RST_EBADPERF;
	case MPTCP_RST_EMIDDLEBOX:
		return SK_RST_REASON_MPTCP_RST_EMIDDLEBOX;
	default:
		/**
		 * It should not happen, or else errors may occur
		 * in MPTCP layer
		 */
		return SK_RST_REASON_ERROR;
	}
}

/* Convert reset reasons in MPTCP to our own enum type */
static inline enum sk_rst_reason convert_dropreason(enum skb_drop_reason reason)
{
	switch (reason) {
	case SKB_DROP_REASON_NOT_SPECIFIED:
		return SK_RST_REASON_NOT_SPECIFIED;
	case SKB_DROP_REASON_NO_SOCKET:
		return SK_RST_REASON_NO_SOCKET;
	default:
		/* If we don't have our own corresponding reason */
		return SK_RST_REASON_NOT_SPECIFIED;
	}
}
#endif
